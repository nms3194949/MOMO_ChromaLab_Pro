<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ChromaLab Pro - v32 Streamlined</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;900&family=Merriweather:wght@400;900&family=Playfair+Display:wght@400;900&family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">

    <style>
        :root {
            --primary: #4f46e5;
            --primary-hover: #4338ca;
            --bg: #f1f5f9;
            --card-bg: #ffffff;
            --text: #334155;
            --border: #cbd5e1;
            /* Mockup */
            --mockup-bg: #eee;
            --mockup-text: #333;
            --mockup-stroke: #000;
            --mockup-width: 3px;
            --mockup-font: 'Inter', sans-serif;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            margin: 0;
            padding: 20px;
            display: flex; flex-direction: column; align-items: center;
            min-height: 100vh;
        }

        .container {
            width: 100%; max-width: 1400px;
            background: var(--card-bg); border-radius: 16px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            padding: 20px; box-sizing: border-box;
        }

        /* Header */
        .header-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; border-bottom: 1px solid var(--border); padding-bottom: 10px; }
        h1 { margin: 0; font-size: 1.25rem; color: var(--primary); display: flex; align-items: center; gap: 8px;}
        
        /* Buttons */
        .btn {
            background: var(--primary); color: white; border: none; padding: 6px 12px; border-radius: 6px;
            cursor: pointer; font-weight: 500; transition: 0.15s; font-size: 0.85rem;
            display: inline-flex; align-items: center; justify-content: center; gap: 4px; text-decoration: none; user-select: none;
            white-space: nowrap; height: 32px; box-sizing: border-box;
        }
        .btn:hover { background: var(--primary-hover); transform: translateY(-1px); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; background: #94a3b8; }
        .btn.danger { background: #ef4444; } .btn.danger:hover { background: #dc2626; }
        .btn.dark { background: #0f172a; } .btn.dark:hover { background: #1e293b; }
        .btn.magic { background: linear-gradient(135deg, #6366f1, #a855f7); }
        .btn.outline { background: transparent; border: 1px solid var(--primary); color: var(--primary); }
        .btn.outline:hover { background: #eef2ff; }
        .btn.outline.active { background: var(--primary); color: white; }
        .btn.secondary { background: #64748b; } .btn.secondary:hover { background: #475569; }
        .btn.warning { background: #f59e0b; color: white; } .btn.warning:hover { background: #d97706; }

        /* Upload */
        .upload-zone { border: 2px dashed #cbd5e1; border-radius: 12px; padding: 60px 20px; text-align: center; cursor: pointer; transition: all 0.2s; background: #f8fafc; }
        .upload-zone:hover { border-color: var(--primary); background: #f1f5f9; }

        .workspace { display: none; flex-direction: column; gap: 15px; }
        
        /* Workbench Panel */
        .workbench-panel {
            background: #f8fafc; border: 1px solid var(--border); border-radius: 12px;
            padding: 12px; display: flex; flex-direction: column; gap: 10px;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.02);
        }
        .panel-row { display: flex; align-items: center; gap: 12px; flex-wrap: wrap; }
        .panel-divider { width: 1px; height: 24px; background: #cbd5e1; margin: 0 5px; }
        .tool-group { display: flex; align-items: center; gap: 8px; background: #fff; padding: 4px 8px; border-radius: 6px; border: 1px solid #e2e8f0; }
        .tool-label { font-size: 0.8rem; font-weight: 600; color: #64748b; margin-right: 4px; display: flex; align-items: center; gap:4px; }
        
        input[type="range"] { width: 80px; cursor: pointer; height: 4px; }
        input[type="color"] { width: 24px; height: 24px; padding: 0; border: none; border-radius: 4px; cursor: pointer; overflow: hidden; }
        input[type="text"] { width: 60px; padding: 2px 4px; font-size: 0.8rem; border: 1px solid #cbd5e1; border-radius: 4px; font-family: monospace; text-transform: uppercase; }
        select { padding: 2px 4px; border: 1px solid #cbd5e1; border-radius: 4px; font-size: 0.8rem; height: 26px; }

        /* Grid */
        .main-split-grid { display: grid; grid-template-columns: 1fr 300px; gap: 20px; align-items: start; }
        .left-column-content { display: flex; flex-direction: column; gap: 15px; }

        /* Canvas */
        .canvas-wrapper { 
            width: 100%; overflow: auto; 
            border: 1px solid var(--border); border-radius: 8px; 
            background-image: linear-gradient(45deg, #ddd 25%, transparent 25%), linear-gradient(-45deg, #ddd 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #ddd 75%), linear-gradient(-45deg, transparent 75%, #ddd 75%); 
            background-size: 20px 20px; background-position: 0 0, 0 10px, 10px -10px, -10px 0px; 
            background-color: #fff;
            max-height: 600px; 
            text-align: center; padding: 20px; box-sizing: border-box; position: relative; 
            cursor: default; 
        }
        canvas { box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1); display: inline-block; max-width: none; }
        .canvas-wrapper.pan-mode { cursor: grab !important; }
        .canvas-wrapper.pan-mode:active { cursor: grabbing !important; }
        .canvas-wrapper.brush-mode { cursor: none !important; }
        .canvas-wrapper.bucket-mode { cursor: cell !important; }

        .brush-cursor { position: fixed; pointer-events: none; border-radius: 50%; border: 2px solid rgba(0,0,0,0.5); box-shadow: 0 0 0 1px rgba(255,255,255,0.8); z-index: 9999; display: none; transform: translate(-50%, -50%); }

        /* Auto Palette */
        .auto-palette-section { margin-bottom: 5px; }
        .palette-row { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 5px; }
        .color-card { flex: 1; min-width: 70px; height: 60px; border-radius: 6px; cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: center; font-family: monospace; color: #fff; text-shadow: 0 1px 2px rgba(0,0,0,0.5); font-size: 0.75rem; transition: transform 0.1s; }
        .color-card:hover { transform: scale(1.05); z-index: 2; }
        .pct-text { font-size: 1.1rem; font-weight: bold; line-height: 1; margin-bottom: 2px; }
        .hex-text { font-size: 0.7rem; opacity: 0.9; }

        /* Mockup */
        .mockup-container { width: 100%; height: 180px; border-radius: 8px; display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; background-color: var(--mockup-bg); border: 1px solid var(--border); overflow: hidden; margin-top: 10px;}
        .mockup-title { font-family: var(--mockup-font); font-size: 3rem; line-height: 1; margin: 0; font-weight: 900; color: var(--mockup-text); -webkit-text-stroke: var(--mockup-width) var(--mockup-stroke); paint-order: stroke fill; text-transform: uppercase; }
        .harmony-panel { background: #fff; padding: 10px; border-radius: 8px; border: 1px solid var(--border); }
        .harmony-group { margin-bottom: 8px; padding: 5px; border-radius: 6px; cursor: pointer;}
        .harmony-group:hover { background: #f1f5f9; }
        .harmony-group.active { background: #eff6ff; border: 1px solid #bfdbfe; }
        .harmony-colors { display: flex; gap: 4px; height: 30px; margin-top: 4px; }
        .h-box { flex: 1; border-radius: 4px; border: 1px solid rgba(0,0,0,0.1); }

        /* Sidebar */
        .sidebar { display: flex; flex-direction: column; gap: 15px; }
        .info-card { background: #fff; padding: 12px; border-radius: 8px; border: 1px solid var(--border); }
        .section-title { font-size: 0.85rem; font-weight: 700; color: #64748b; margin-bottom: 8px; display: flex; justify-content: space-between; align-items: center;}
        .live-swatch { height: 40px; border-radius: 6px; margin-bottom: 8px; border: 1px solid #ddd; position: relative; overflow: hidden; background-image: linear-gradient(45deg, #ccc 25%, transparent 25%), linear-gradient(-45deg, #ccc 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #ccc 75%), linear-gradient(-45deg, transparent 75%, #ccc 75%); background-size: 8px 8px; }
        .live-swatch::after { content: ''; position: absolute; top:0; left:0; width:100%; height:100%; background-color: var(--swatch-color, transparent); }
        .value-row { display: flex; justify-content: space-between; font-family: monospace; font-size: 0.8rem; padding: 4px 0; border-bottom: 1px dashed #eee; cursor: pointer;}
        .value-row:last-child { border-bottom: none; }
        .value-row:hover { color: var(--primary); }
        
        .history-list, .saved-list { display: flex; flex-direction: column; gap: 4px; max-height: 120px; overflow-y: auto; }
        .history-item, .saved-item { display: flex; align-items: center; gap: 8px; padding: 4px; border-radius: 4px; cursor: pointer; border: 1px solid transparent; }
        .history-item:hover, .saved-item:hover { background: #f8fafc; border-color: #e2e8f0; }
        .history-swatch, .saved-swatch { width: 16px; height: 16px; border-radius: 3px; border: 1px solid #ddd; flex-shrink: 0; }
        
        .shades-grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 4px; margin-top: 5px; }
        .shade-box { height: 30px; border-radius: 4px; cursor: pointer; position: relative; }
        .shade-box:hover { transform: scale(1.1); z-index: 2; box-shadow: 0 2px 5px rgba(0,0,0,0.2); }
        
        .gradient-box { height: 60px; width: 100%; border-radius: 6px; cursor: pointer; position: relative; background: #eee; border: 1px solid #ddd; margin-top:5px; }
        .gradient-box::after { content: "é»æ“Šè¤‡è£½ CSS"; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #fff; text-shadow: 0 1px 2px rgba(0,0,0,0.5); font-size: 0.8rem; opacity: 0; transition: 0.2s; }
        .gradient-box:hover::after { opacity: 1; }

        .saved-list { max-height: 200px; overflow-y: auto; display: flex; flex-direction: column; gap: 8px; }
        .saved-item { display: flex; align-items: center; justify-content: space-between; padding: 8px; background: #fff; border: 1px solid #e2e8f0; border-radius: 6px; }
        .saved-info { display: flex; align-items: center; gap: 8px; cursor: pointer; flex: 1; }
        .saved-swatch { width: 20px; height: 20px; border-radius: 4px; border: 1px solid #ddd; flex-shrink: 0; }
        .delete-btn { color: #ef4444; cursor: pointer; font-weight: bold; padding: 0 5px; }

        .magnifier { position: fixed; pointer-events: none; border: 3px solid #fff; box-shadow: 0 0 0 2px var(--primary), 0 10px 20px rgba(0,0,0,0.2); border-radius: 50%; width: 120px; height: 120px; overflow: hidden; display: none; z-index: 100; background: #fff; }
        .magnifier canvas { width: 100%; height: 100%; image-rendering: pixelated; }

        @media (max-width: 1024px) { .main-split-grid { grid-template-columns: 1fr; } }
    </style>
</head>
<body>

<div id="brushCursor" class="brush-cursor"></div>

<svg style="display: none;">
    <defs>
        <filter id="protanopia"><feColorMatrix type="matrix" values="0.567, 0.433, 0, 0, 0 0.558, 0.442, 0, 0, 0 0, 0.242, 0.758, 0, 0 0, 0, 1, 0"/></filter>
        <filter id="deuteranopia"><feColorMatrix type="matrix" values="0.625, 0.375, 0, 0, 0 0.7, 0.3, 0, 0, 0 0, 0.3, 0.7, 0, 0 0, 0, 0, 1, 0"/></filter>
        <filter id="tritanopia"><feColorMatrix type="matrix" values="0.95, 0.05, 0, 0, 0 0, 0.433, 0.567, 0, 0 0, 0.475, 0.525, 0, 0 0, 0, 0, 1, 0"/></filter>
        <filter id="grayscale"><feColorMatrix type="matrix" values="0.3333, 0.3333, 0.3333, 0, 0 0.3333, 0.3333, 0.3333, 0, 0 0.3333, 0.3333, 0.3333, 0, 0 0, 0, 0, 1, 0"/></filter>
    </defs>
</svg>

<div class="container">
    <div class="header-row">
        <h1>ğŸ¨ ChromaLab Pro <span style="font-size:0.75rem; background:#e0e7ff; color:var(--primary); padding:2px 6px; border-radius:4px; margin-left:8px;">v32 Streamlined</span></h1>
        <button class="btn danger small" id="resetBtn" style="display:none;">ğŸ”„ é‡ç½®å°ˆæ¡ˆ</button>
    </div>
    
    <div class="upload-zone" id="uploadZone">
        <div style="font-size: 2.5rem; margin-bottom: 10px;">ğŸ–¼ï¸</div>
        <h3>é»æ“Šä¸Šå‚³ / æ‹–æ”¾åœ–ç‰‡ / Ctrl+V</h3>
        <input type="file" id="fileInput" accept="image/*" style="display:none;">
    </div>

    <div class="workspace visual-filter-layer" id="workspace">
        
        <div class="auto-palette-section">
            <div class="palette-row" id="paletteContainer"></div>
        </div>

        <div class="workbench-panel">
            <div class="panel-row">
                <div class="tool-group">
                    <span class="tool-label">ğŸ”</span>
                    <input type="range" id="zoomSlider" min="10" max="1000" value="100" title="ç¸®æ”¾">
                    <span id="zoomLabel" style="font-size:0.75rem; font-family:monospace; width:35px; text-align:right;">100%</span>
                </div>
                <button class="btn outline small" id="panToolBtn" onclick="togglePanMode()" title="æŠ“æ‰‹å·¥å…· (Space)">âœ‹ æŠ“æ‰‹</button>
                
                <div class="panel-divider"></div>

                <div class="tool-group">
                    <span class="tool-label">ğŸ¯ ç›®æ¨™</span>
                    <input type="color" id="targetColorPicker" value="#ffffff">
                    <input type="text" id="targetHexInput" value="#FFFFFF">
                    <button class="btn small outline" onclick="pasteTargetHex()" title="å¾å‰ªè²¼ç°¿è²¼ä¸Šè‰²ç¢¼">ğŸ“‹</button>
                </div>
                <span style="color:#94a3b8;">âœ</span>
                <div class="tool-group">
                    <span class="tool-label">ğŸ¨ æ›¿æ›</span>
                    <input type="color" id="replaceColorPicker" value="#ff0000">
                    <input type="text" id="replaceHexInput" value="#FF0000">
                    <button class="btn small outline" onclick="pasteReplaceHex()" title="å¾å‰ªè²¼ç°¿è²¼ä¸Šè‰²ç¢¼">ğŸ“‹</button>
                </div>

                <div class="panel-divider"></div>
                
                <select id="a11ySelect" onchange="applyA11yFilter(this.value)" title="è‰²ç›²æ¨¡æ“¬">
                    <option value="none">æ­£å¸¸è¦–è¦º</option>
                    <option value="protanopia">ç´…è‰²ç›²</option>
                    <option value="deuteranopia">ç¶ è‰²ç›²</option>
                    <option value="tritanopia">è—è‰²ç›²</option>
                    <option value="grayscale">å…¨è‰²ç›²</option>
                </select>
            </div>

            <div class="panel-row">
                <div class="tool-group">
                    <span class="tool-label">ğŸšï¸ å®¹è¨±åº¦</span>
                    <input type="range" id="toleranceSlider" min="1" max="120" value="30">
                    <span id="tolVal" style="font-size:0.75rem; font-family:monospace; width:25px;">30</span>
                </div>
                <div class="tool-group">
                    <span class="tool-label">ğŸª¶ æŸ”åŒ–</span>
                    <input type="range" id="featherSlider" min="0" max="50" value="10">
                    <span id="featherVal" style="font-size:0.75rem; font-family:monospace; width:25px;">10</span>
                </div>
                
                <div class="panel-divider"></div>

                <div class="tool-group">
                    <label style="display:flex; align-items:center; gap:4px; font-size:0.8rem; cursor:pointer; padding-right:5px;">
                        <input type="checkbox" id="contiguousCheck"> ğŸª£ é€£çºŒå€åŸŸ
                    </label>
                </div>

                <div class="panel-divider"></div>

                <button class="btn outline small" id="toggleBrushBtn" onclick="toggleBrushMode()">ğŸ–Œï¸ ç­†åˆ·</button>
                <div id="brushControls" style="display:none; align-items:center; gap:8px;">
                    <div class="tool-group">
                        <label style="font-size:0.75rem;"><input type="radio" name="brushMode" value="restore" checked> å¾©åŸ</label>
                        <label style="font-size:0.75rem;"><input type="radio" name="brushMode" value="paint"> ä¸Šè‰²</label>
                    </div>
                    <div class="tool-group">
                        <span class="tool-label">å¤§å°</span>
                        <input type="range" id="brushSizeSlider" min="5" max="200" value="30">
                        <span id="brushSizeVal" style="font-size:0.75rem; font-family:monospace;">30</span>
                    </div>
                </div>
            </div>

            <div class="panel-row" style="background:transparent; border:none; padding:0; box-shadow:none;">
                <button class="btn warning" id="undoBtn" onclick="undoLastAction()" disabled>â†©ï¸ å¾©åŸ</button>
                <div class="panel-divider"></div>
                <button class="btn magic" id="replaceBtn" onclick="handleReplaceAction()">ğŸ”„ æ›¿æ›</button>
                <button class="btn outline" onclick="applyColorModification('transparent')">âœ¨ å»èƒŒ</button>
                <button class="btn" id="compareBtn" style="background:#475569;">ğŸ‘ï¸ æŒ‰ä½æ¯”å°</button>
                <div class="panel-divider"></div>
                <button class="btn secondary" onclick="resetImage()">â†©ï¸ é‡ç½®</button>
                <button class="btn dark" onclick="downloadModifiedImage()">ğŸ’¾ ä¸‹è¼‰ PNG</button>
            </div>
        </div>

        <div class="main-split-grid">
            <div class="left-column-content">
                <div class="canvas-wrapper" id="canvasWrapper">
                    <canvas id="mainCanvas"></canvas>
                </div>

                <div class="mockup-section" id="mockupSection" style="display:none;">
                    <div class="section-title">
                        ğŸ‘ï¸ é è¦½ & é…è‰²å»ºè­°
                        <div class="mockup-controls" style="font-size:0.8rem; display:flex; gap:10px; align-items:center;">
                            <label>é‚Šæ¡† <input type="range" id="strokeSlider" min="0" max="15" step="0.5" value="3" style="width:50px; vertical-align:middle;"></label>
                            <select id="fontSelect" onchange="changeMockupFont(this.value)">
                                <option value="'Inter', sans-serif">ç„¡è¥¯ç·š</option>
                                <option value="'Playfair Display', serif">è¥¯ç·š</option>
                                <option value="'Merriweather', serif">é–±è®€</option>
                                <option value="'Roboto Mono', monospace">å·¥ç¨‹</option>
                            </select>
                            <button class="btn outline small" onclick="swapMockupColors()">â‡„ äº¤æ›</button>
                        </div>
                    </div>
                    
                    <div style="display:grid; grid-template-columns: 1fr 1fr; gap:15px;">
                        <div class="mockup-container" id="mockupBox">
                            <div class="mockup-title">DESIGN<br>MOCKUP</div>
                            <div class="mockup-sub">Contrast Preview</div>
                        </div>
                        <div class="harmony-panel">
                            <div id="harmonyContainer" style="opacity:0.5; pointer-events:none;">
                                <div class="harmony-group" id="group-ana"><div class="harmony-label">ç›¸ä¼¼è‰²</div><div class="harmony-colors" id="harmony-ana"></div></div>
                                <div class="harmony-group" id="group-tri"><div class="harmony-label">ä¸‰è§’è‰²</div><div class="harmony-colors" id="harmony-tri"></div></div>
                                <div class="harmony-group" id="group-comp"><div class="harmony-label">äº’è£œè‰²</div><div class="harmony-colors" id="harmony-comp"></div></div>
                                <div class="harmony-group" id="group-split"><div class="harmony-label">åˆ†è£‚äº’è£œ</div><div class="harmony-colors" id="harmony-split"></div></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="sidebar">
                <button id="eyeDropperBtn" class="btn magic" style="width:100%; display:none;">ğŸ–Šï¸ è¢å¹•å¸ç®¡</button>
                <div class="info-card">
                    <div class="section-title">
                        è‰²å½©æ•¸å€¼ 
                        <button onclick="saveCurrentColor()" class="btn small outline" style="padding:1px 6px; height:20px; font-size:0.7rem;">ğŸ’¾ æ”¶è—</button>
                    </div>
                    <div class="live-swatch" id="liveSwatch"></div>
                    <div class="value-row" onclick="copyText(document.getElementById('valHex').innerText)"><span class="label">HEX</span><span class="val" id="valHex">#FFFFFF</span></div>
                    <div class="value-row" onclick="copyText(document.getElementById('valRgb').innerText)"><span class="label">RGB</span><span class="val" id="valRgb">255, 255, 255</span></div>
                    <div class="value-row" onclick="copyText(document.getElementById('valCmyk').innerText)"><span class="label">CMYK</span><span class="val" id="valCmyk">0, 0, 0, 0</span></div>
                    <div class="value-row" onclick="copyText(document.getElementById('valOklch').innerText)"><span class="label">OKLCH</span><span class="val" id="valOklch">0%, 0, 0</span></div>
                </div>
                
                <div class="info-card">
                    <div class="section-title">ğŸ•’ é»æ“Šç´€éŒ„</div>
                    <div class="history-list" id="historyList"><div style="color:#999; font-size:0.8rem; text-align:center;">é»æ“Šç•«å¸ƒä»¥ç´€éŒ„</div></div>
                </div>
                
                <div class="info-card">
                    <div class="section-title">
                        ğŸ“ å·²æ”¶è—
                        <button onclick="clearSavedColors()" style="border:none; background:none; cursor:pointer; font-size:0.8rem;">ğŸ—‘ï¸</button>
                    </div>
                    <div class="saved-list" id="savedList"><div style="color:#999; font-size:0.8rem; text-align:center;">æš«ç„¡æ”¶è—</div></div>
                </div>

                <div class="info-card">
                    <div class="section-title">ğŸ“Š ç³»çµ±è‰²éš</div>
                    <div id="shadesContainer" class="shades-grid" style="grid-template-columns: repeat(5, 1fr); gap:2px;"><div style="grid-column:1/-1; color:#999; font-size:0.8rem; text-align:center;">é»æ“Šè‰²ç¥¨ç”Ÿæˆ</div></div>
                    <button onclick="exportTailwindConfig()" class="btn outline small" style="width:100%; margin-top:5px;">ğŸ“‹ è¤‡è£½ Tailwind</button>
                </div>
                
                <div class="info-card">
                    <div class="section-title">ğŸŒˆ æ¼¸å±¤ç”¢ç”Ÿå™¨</div>
                    <div class="gradient-box" id="gradientPreview" onclick="copyGradient()"></div>
                </div>
                
                <button onclick="downloadPaletteCard()" class="btn" style="width:100%; background:linear-gradient(to right, #ec4899, #8b5cf6);">ğŸ“¸ ä¸‹è¼‰è‰²å¡åœ–</button>
            </div>
        </div>
    </div>
</div>

<div id="magnifier" class="magnifier"><canvas id="magCanvas"></canvas></div>

<script>
    // --- Global Variables ---
    const mainCanvas = document.getElementById('mainCanvas');
    const ctx = mainCanvas.getContext('2d', { willReadFrequently: true });
    const canvasWrapper = document.getElementById('canvasWrapper');
    const brushCursor = document.getElementById('brushCursor');
    
    // Tools
    const panToolBtn = document.getElementById('panToolBtn');
    const toggleBrushBtn = document.getElementById('toggleBrushBtn');
    const brushControls = document.getElementById('brushControls');
    const brushSizeSlider = document.getElementById('brushSizeSlider');
    const compareBtn = document.getElementById('compareBtn');
    const contiguousCheck = document.getElementById('contiguousCheck');
    const mockupBox = document.getElementById('mockupBox'); 
    const replaceBtn = document.getElementById('replaceBtn'); 
    
    // Values
    const strokeSlider = document.getElementById('strokeSlider');
    const toleranceSlider = document.getElementById('toleranceSlider');
    const featherSlider = document.getElementById('featherSlider');
    const undoBtn = document.getElementById('undoBtn');
    
    // Sidebar Elements
    const historyList = document.getElementById('historyList');
    const shadesContainer = document.getElementById('shadesContainer');
    const savedList = document.getElementById('savedList');
    const gradientPreview = document.getElementById('gradientPreview');

    let originalImageData = null;
    let undoStack = [];
    const MAX_STACK_SIZE = 20;
    
    // History Data
    let colorHistory = [];
    let currentShades = {};
    let currentMainColor = "#FFFFFF";
    let currentGradientCSS = "";

    // States
    let isPanMode = false;
    let isPanning = false;
    let startPanX, startPanY, startScrollLeft, startScrollTop;
    
    let isBrushMode = false;
    let isDrawing = false;
    let sourceImage = null; 
    
    let isFloodFillActive = false;

    // Initialize
    window.addEventListener('DOMContentLoaded', () => {
        loadSavedColors();
        const magCtx = document.getElementById('magCanvas').getContext('2d');
        magCtx.imageSmoothingEnabled = false; 
    });
    
    document.getElementById('magCanvas').width = 120;
    document.getElementById('magCanvas').height = 120;

    // --- 1. Zoom Logic ---
    const zoomSlider = document.getElementById('zoomSlider');
    const zoomLabel = document.getElementById('zoomLabel');
    zoomSlider.addEventListener('input', (e) => {
        const val = e.target.value;
        mainCanvas.style.width = `${val}%`; 
        zoomLabel.innerText = `${val}%`;
    });

    // --- 2. Pan Tool Logic ---
    function togglePanMode() {
        if(isBrushMode) toggleBrushMode(); 
        isPanMode = !isPanMode;
        
        if(isPanMode) {
            panToolBtn.classList.add('active');
            canvasWrapper.classList.add('pan-mode');
            mainCanvas.style.pointerEvents = 'none'; 
        } else {
            panToolBtn.classList.remove('active');
            canvasWrapper.classList.remove('pan-mode');
            mainCanvas.style.pointerEvents = 'auto';
        }
    }

    canvasWrapper.addEventListener('mousedown', (e) => {
        if(!isPanMode) return;
        isPanning = true;
        startPanX = e.pageX;
        startPanY = e.pageY;
        startScrollLeft = canvasWrapper.scrollLeft;
        startScrollTop = canvasWrapper.scrollTop;
    });

    canvasWrapper.addEventListener('mousemove', (e) => {
        if(!isPanning) return;
        const x = e.pageX - startPanX;
        const y = e.pageY - startPanY;
        canvasWrapper.scrollLeft = startScrollLeft - x;
        canvasWrapper.scrollTop = startScrollTop - y;
    });

    canvasWrapper.addEventListener('mouseup', () => isPanning = false);
    canvasWrapper.addEventListener('mouseleave', () => isPanning = false);

    // --- 3. Compare Button Logic ---
    compareBtn.addEventListener('mousedown', () => {
        if(!originalImageData) return;
        const currentData = ctx.getImageData(0, 0, mainCanvas.width, mainCanvas.height);
        ctx.putImageData(originalImageData, 0, 0);
        const restore = () => { ctx.putImageData(currentData, 0, 0); document.removeEventListener('mouseup', restore); };
        document.addEventListener('mouseup', restore);
    });

    // --- 4. Brush Logic ---
    function toggleBrushMode() {
        if(isPanMode) togglePanMode();
        if(isFloodFillActive) toggleFloodFillMode(); // Close flood fill if opening brush
        
        isBrushMode = !isBrushMode;

        if(isBrushMode) {
            canvasWrapper.classList.add('brush-mode');
            toggleBrushBtn.classList.add('active');
            brushControls.style.display = 'flex';
            brushCursor.style.display = 'block';
        } else {
            canvasWrapper.classList.remove('brush-mode');
            toggleBrushBtn.classList.remove('active');
            brushControls.style.display = 'none';
            brushCursor.style.display = 'none';
        }
    }

    document.addEventListener('mousemove', (e) => {
        if(!isBrushMode) return;
        const size = parseInt(brushSizeSlider.value);
        brushCursor.style.width = `${size}px`;
        brushCursor.style.height = `${size}px`;
        brushCursor.style.left = `${e.clientX}px`;
        brushCursor.style.top = `${e.clientY}px`;
        
        if(e.target === mainCanvas || e.target.closest('.canvas-wrapper')) {
            brushCursor.style.display = 'block';
        } else {
            brushCursor.style.display = 'none';
        }
    });

    brushSizeSlider.addEventListener('input', (e) => {
        document.getElementById('brushSizeVal').innerText = e.target.value;
    });

    mainCanvas.addEventListener('mousedown', (e) => {
        if(isBrushMode) {
            isDrawing = true;
            saveCanvasState();
            performBrush(e);
        }
    });
    mainCanvas.addEventListener('mousemove', (e) => {
        if(isBrushMode && isDrawing) performBrush(e);
        
        // Live Monitor
        if(!isBrushMode && !isPanMode && !isFloodFillActive) {
            const coords = getCanvasCoords(e);
            if(coords) {
                const pixel = ctx.getImageData(coords.x, coords.y, 1, 1).data;
                const r = pixel[0]; const g = pixel[1]; const b = pixel[2];
                const hex = rgbToHex(r, g, b);
                updateColorInfo(r, g, b, hex);
                // v29: Tighter Magnifier
                updateMagnifier(e, coords);
            }
        }
    });
    mainCanvas.addEventListener('mouseup', () => isDrawing = false);
    
    // Click Behavior (Locks color)
    mainCanvas.addEventListener('click', (e) => {
        if(isBrushMode || isPanMode || isFloodFillActive) return; 
        const coords = getCanvasCoords(e);
        if(!coords) return;
        const pixel = ctx.getImageData(coords.x, coords.y, 1, 1).data;
        const [r, g, b] = pixel;
        const hex = rgbToHex(r,g,b);
        updateColorInfo(r, g, b, hex);
        calculateHarmonies(r, g, b);
        addToHistory(hex);
    });

    function performBrush(e) {
        if(!sourceImage) return;
        const coords = getCanvasCoords(e);
        if(!coords) return;
        const size = parseInt(brushSizeSlider.value);
        const radius = size / 2;
        const mode = document.querySelector('input[name="brushMode"]:checked').value;
        ctx.save();
        ctx.beginPath();
        ctx.arc(coords.x, coords.y, radius, 0, Math.PI * 2);
        ctx.clip();
        if (mode === 'restore') {
            ctx.drawImage(sourceImage, 0, 0, mainCanvas.width, mainCanvas.height);
        } else {
            const hex = document.getElementById('replaceColorPicker').value;
            ctx.fillStyle = hex;
            ctx.fillRect(0, 0, mainCanvas.width, mainCanvas.height);
        }
        ctx.restore();
    }

    // --- 5. Image Editor Logic ---
    function hexToRgbObj(hex) {
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return { r, g, b };
    }

    // v30: Paste Clipboard Function (Target)
    async function pasteTargetHex() {
        try {
            const text = await navigator.clipboard.readText();
            const cleanText = text.trim().replace('#', '');
            if (/^[0-9A-Fa-f]{6}$/.test(cleanText)) {
                const hex = '#' + cleanText;
                document.getElementById('targetColorPicker').value = hex;
                document.getElementById('targetHexInput').value = hex.toUpperCase();
                const btn = document.querySelector('button[title="å¾å‰ªè²¼ç°¿è²¼ä¸Šè‰²ç¢¼"]');
                const orig = btn.innerText; btn.innerText = "âœ…"; setTimeout(()=>btn.innerText = orig, 1000);
            } else { alert('å‰ªè²¼ç°¿å…§å®¹ä¸æ˜¯æœ‰æ•ˆçš„ HEX è‰²ç¢¼'); }
        } catch (err) { alert('ç„¡æ³•å­˜å–å‰ªè²¼ç°¿ (ç€è¦½å™¨å®‰å…¨é™åˆ¶)ã€‚è«‹ä½¿ç”¨ Ctrl+V è²¼ä¸Šï¼Œæˆ–ç¢ºèªå·²æˆäºˆæ¬Šé™ã€‚'); }
    }

    // v31: Paste Clipboard Function (Replace)
    async function pasteReplaceHex() {
        try {
            const text = await navigator.clipboard.readText();
            const cleanText = text.trim().replace('#', '');
            if (/^[0-9A-Fa-f]{6}$/.test(cleanText)) {
                const hex = '#' + cleanText;
                document.getElementById('replaceColorPicker').value = hex;
                document.getElementById('replaceHexInput').value = hex.toUpperCase();
                const btn = document.querySelector('button[onclick="pasteReplaceHex()"]');
                if(btn) {
                    const orig = btn.innerText; btn.innerText = "âœ…"; setTimeout(()=>btn.innerText = orig, 1000);
                }
            } else { alert('å‰ªè²¼ç°¿å…§å®¹ä¸æ˜¯æœ‰æ•ˆçš„ HEX è‰²ç¢¼'); }
        } catch (err) { alert('ç„¡æ³•å­˜å–å‰ªè²¼ç°¿ (ç€è¦½å™¨å®‰å…¨é™åˆ¶)ã€‚è«‹ä½¿ç”¨ Ctrl+V è²¼ä¸Šï¼Œæˆ–ç¢ºèªå·²æˆäºˆæ¬Šé™ã€‚'); }
    }

    function handleReplaceAction() {
        if (!originalImageData) return;
        if (contiguousCheck.checked) {
            toggleFloodFillMode();
        } else {
            applyColorModification('replace');
        }
    }

    function toggleFloodFillMode() {
        isFloodFillActive = !isFloodFillActive;
        if(isFloodFillActive) {
            if(isBrushMode) toggleBrushMode(); 
            if(isPanMode) togglePanMode(); 
            
            replaceBtn.innerText = "ğŸ›‘ åœæ­¢å¡«è‰²";
            replaceBtn.classList.add('danger'); replaceBtn.classList.remove('magic');
            canvasWrapper.classList.add('bucket-mode');
            
            mainCanvas.addEventListener('click', floodFillClickHandler);
        } else {
            replaceBtn.innerText = "ğŸ”„ æ›¿æ›";
            replaceBtn.classList.remove('danger'); replaceBtn.classList.add('magic');
            canvasWrapper.classList.remove('bucket-mode');
            mainCanvas.removeEventListener('click', floodFillClickHandler);
        }
    }

    const floodFillClickHandler = (e) => {
        if(!isFloodFillActive) return;
        
        const targetHex = document.getElementById('targetColorPicker').value;
        const replaceHex = document.getElementById('replaceColorPicker').value;
        const targetRgb = hexToRgbObj(targetHex);
        const replaceRgb = hexToRgbObj(replaceHex);
        const tolerance = parseInt(toleranceSlider.value);
        
        const coords = getCanvasCoords(e);
        if(coords) {
            saveCanvasState();
            floodFill(coords.x, coords.y, targetRgb, replaceRgb, tolerance);
        }
    };

    function applyColorModification(mode) {
        if (!originalImageData) return;
        saveCanvasState();

        const targetHex = document.getElementById('targetColorPicker').value;
        const replaceHex = document.getElementById('replaceColorPicker').value;
        const targetRgb = hexToRgbObj(targetHex);
        const replaceRgb = hexToRgbObj(replaceHex);
        
        const tolerance = parseInt(toleranceSlider.value);
        const feather = parseInt(featherSlider.value);

        processGlobal(mode, targetRgb, replaceRgb, tolerance, feather);
    }

    function processGlobal(mode, targetRgb, replaceRgb, tolerance, feather) {
        const imgData = ctx.getImageData(0, 0, mainCanvas.width, mainCanvas.height);
        const data = imgData.data;
        const tolDist = tolerance;
        const maxDist = tolerance + feather;

        for (let i = 0; i < data.length; i += 4) {
            const r = data[i], g = data[i+1], b = data[i+2];
            const dist = Math.sqrt((r - targetRgb.r)**2 + (g - targetRgb.g)**2 + (b - targetRgb.b)**2);

            if (mode === 'transparent') {
                if (dist < tolDist) {
                    data[i+3] = 0;
                } else if (dist < maxDist && feather > 0) {
                    const factor = (dist - tolDist) / feather; 
                    data[i+3] = Math.floor(factor * 255);
                }
            } else if (mode === 'replace') {
                if (dist < tolDist) {
                    data[i] = replaceRgb.r; data[i+1] = replaceRgb.g; data[i+2] = replaceRgb.b;
                } else if (dist < maxDist && feather > 0) {
                     const factor = 1 - ((dist - tolDist) / feather);
                     data[i] += (replaceRgb.r - data[i]) * factor;
                     data[i+1] += (replaceRgb.g - data[i+1]) * factor;
                     data[i+2] += (replaceRgb.b - data[i+2]) * factor;
                }
            }
        }
        ctx.putImageData(imgData, 0, 0);
        generateAutoPaletteFromCanvas();
    }

    function floodFill(startX, startY, targetRgb, replaceRgb, tolerance) {
        const imgData = ctx.getImageData(0, 0, mainCanvas.width, mainCanvas.height);
        const data = imgData.data;
        const w = mainCanvas.width;
        const h = mainCanvas.height;
        const stack = [startX, startY];
        const visited = new Uint8Array(w * h); 
        
        const isMatch = (idx) => {
            const r = data[idx], g = data[idx+1], b = data[idx+2];
            const dist = Math.sqrt((r - targetRgb.r)**2 + (g - targetRgb.g)**2 + (b - targetRgb.b)**2);
            return dist <= tolerance;
        };

        while(stack.length > 0) {
            const y = stack.pop();
            const x = stack.pop();
            const idx = (y * w + x) * 4;
            if (x < 0 || x >= w || y < 0 || y >= h || visited[y * w + x]) continue;
            
            if (isMatch(idx)) {
                data[idx] = replaceRgb.r; data[idx+1] = replaceRgb.g; data[idx+2] = replaceRgb.b;
                visited[y * w + x] = 1;
                stack.push(x + 1, y); stack.push(x - 1, y); stack.push(x, y + 1); stack.push(x, y - 1);
            }
        }
        ctx.putImageData(imgData, 0, 0);
        generateAutoPaletteFromCanvas();
    }

    // --- Core & Helper Functions ---
    function saveCanvasState() {
        undoStack.push(ctx.getImageData(0, 0, mainCanvas.width, mainCanvas.height));
        if (undoStack.length > MAX_STACK_SIZE) undoStack.shift();
        undoBtn.disabled = false;
    }
    function undoLastAction() {
        if (undoStack.length === 0) return;
        ctx.putImageData(undoStack.pop(), 0, 0);
        undoBtn.disabled = undoStack.length === 0;
        generateAutoPaletteFromCanvas();
    }

    // File Input
    const fileInput = document.getElementById('fileInput');
    const uploadZone = document.getElementById('uploadZone');
    uploadZone.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', (e) => handleFile(e.target.files[0]));
    document.addEventListener('paste', (e) => {
        const items = e.clipboardData.items;
        for (let item of items) if (item.type.indexOf('image') !== -1) handleFile(item.getAsFile());
    });
    
    function handleFile(file) {
        if (!file || !file.type.startsWith('image/')) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            const img = new Image();
            img.onload = () => {
                sourceImage = img;
                mainCanvas.width = img.width; mainCanvas.height = img.height;
                ctx.drawImage(img, 0, 0);
                originalImageData = ctx.getImageData(0, 0, mainCanvas.width, mainCanvas.height);
                undoStack = []; undoBtn.disabled = true;
                document.getElementById('workspace').style.display = 'flex';
                uploadZone.style.display = 'none';
                document.getElementById('resetBtn').style.display = 'block';
                let initialScale = 100;
                if(img.width > 800) initialScale = Math.floor((800/img.width)*100);
                zoomSlider.value = initialScale; mainCanvas.style.width = `${initialScale}%`; zoomLabel.innerText = `${initialScale}%`;
                generateAutoPaletteFromCanvas();
            };
            img.src = e.target.result;
        };
        reader.readAsDataURL(file);
    }

    // Pickers Sync
    const pickerIds = [['targetColorPicker','targetHexInput'], ['replaceColorPicker','replaceHexInput']];
    pickerIds.forEach(([pId, iId]) => {
        const p = document.getElementById(pId), i = document.getElementById(iId);
        p.addEventListener('input', (e) => i.value = e.target.value.toUpperCase());
        i.addEventListener('change', (e) => {
            let v = e.target.value; if(!v.startsWith('#')) v='#'+v;
            if(/^#[0-9A-F]{6}$/i.test(v)) { p.value=v; i.value=v.toUpperCase(); }
        });
    });

    // Sliders Text Update
    toleranceSlider.addEventListener('input', (e) => document.getElementById('tolVal').innerText = e.target.value);
    featherSlider.addEventListener('input', (e) => document.getElementById('featherVal').innerText = e.target.value);
    
    strokeSlider.addEventListener('input', (e) => {
        const val = e.target.value;
        mockupBox.style.setProperty('--mockup-width', `${val}px`);
    });

    function setTargetFromCurrent() { if(currentMainColor) { document.getElementById('targetColorPicker').value = currentMainColor; document.getElementById('targetHexInput').value = currentMainColor; } }
    function resetImage() { if(!originalImageData) return; saveCanvasState(); ctx.putImageData(originalImageData, 0, 0); generateAutoPaletteFromCanvas(); }
    function downloadModifiedImage() { const a = document.createElement('a'); a.download = 'edited.png'; a.href = mainCanvas.toDataURL(); a.click(); }
    
    function getCanvasCoords(e) {
        const rect = mainCanvas.getBoundingClientRect();
        if(e.clientX < rect.left || e.clientX > rect.right || e.clientY < rect.top || e.clientY > rect.bottom) return null;
        return { x: Math.floor((e.clientX - rect.left) * (mainCanvas.width / rect.width)), y: Math.floor((e.clientY - rect.top) * (mainCanvas.height / rect.height)) };
    }
    
    function updateColorInfo(r, g, b, hex) {
        currentMainColor = hex;
        document.getElementById('liveSwatch').style.setProperty('--swatch-color', hex);
        document.getElementById('valHex').innerText = hex;
        document.getElementById('valRgb').innerText = `${r}, ${g}, ${b}`;
        const cmyk = rgbToCmyk(r, g, b);
        document.getElementById('valCmyk').innerText = `${cmyk.c}, ${cmyk.m}, ${cmyk.y}, ${cmyk.k}`;
        const oklch = rgbToOklch(r, g, b);
        document.getElementById('valOklch').innerText = oklch;
        generateShades(r, g, b);
    }
    
    function applyA11yFilter(mode) { document.getElementById('workspace').style.filter = mode==='none' ? 'none' : `url(#${mode})`; }
    function changeMockupFont(fontFamily) { mockupBox.style.setProperty('--mockup-font', fontFamily); }
    
    function generateAutoPaletteFromCanvas() {
        const smC = document.createElement('canvas'); const smCtx = smC.getContext('2d');
        smC.width=100; smC.height=100; smCtx.drawImage(mainCanvas, 0,0,mainCanvas.width,mainCanvas.height,0,0,100,100);
        const data=smCtx.getImageData(0,0,100,100).data; const counts={};
        let totalValidPixels = 0;
        for(let i=0; i<data.length; i+=4) { 
            if(data[i+3]<128) continue; 
            totalValidPixels++;
            const r = Math.floor(data[i]/10)*10; const g = Math.floor(data[i+1]/10)*10; const b = Math.floor(data[i+2]/10)*10;
            const k=`${r},${g},${b}`; counts[k]=(counts[k]||0)+1; 
        }
        const sorted = Object.entries(counts).sort((a,b)=>b[1]-a[1]).slice(0,7);
        const container = document.getElementById('paletteContainer'); container.innerHTML='';
        sorted.forEach(([k])=>{
            const [r,g,b]=k.split(',').map(Number); const hex=rgbToHex(r,g,b);
            const pct = ((counts[k]/totalValidPixels)*100).toFixed(1);
            const d=document.createElement('div'); d.className='color-card'; d.style.background=`rgb(${r},${g},${b})`;
            d.innerHTML=`<span class="pct-text">${pct}%</span><span class="hex-text">${hex}</span>`;
            d.onclick=()=>{ updateColorInfo(r,g,b,hex); copyText(hex); calculateHarmonies(r, g, b); addToHistory(hex); }; container.appendChild(d);
        });
    }

    function updateMagnifier(e, coords) {
        const m = document.getElementById('magnifier'); m.style.display='block';
        m.style.left=`${e.pageX + 10}px`; m.style.top=`${e.pageY + 10}px`;
        const ctx = document.getElementById('magCanvas').getContext('2d');
        ctx.fillStyle='#fff'; ctx.fillRect(0,0,120,120);
        ctx.drawImage(mainCanvas, coords.x-15, coords.y-15, 30, 30, 0, 0, 120, 120);
        ctx.strokeStyle='rgba(255,0,0,0.5)'; ctx.strokeRect(60,0,0,120); ctx.strokeRect(0,60,120,0);
    }
    
    function copyText(t) { 
        navigator.clipboard.writeText(t).then(() => {
            const toast = document.createElement('div');
            toast.style.cssText = "position:fixed;bottom:20px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,0.8);color:white;padding:5px 10px;border-radius:5px;z-index:9999;";
            toast.innerText = "Copied!";
            document.body.appendChild(toast);
            setTimeout(()=>toast.remove(), 1000);
        });
    }
    function rgbToHex(r,g,b) { return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase(); }
    
    // --- Side Bar Logic ---
    function generateShades(r, g, b) {
        shadesContainer.innerHTML = '';
        currentShades = {};
        const [h, s, l] = rgbToHsl(r, g, b);
        const levels = [0.95, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1];
        const labels = [50, 100, 200, 300, 400, 500, 600, 700, 800, 900];
        levels.forEach((targetL, i) => {
            const [newR, newG, newB] = hslToRgb(h, s, targetL);
            const hex = rgbToHex(newR, newG, newB);
            currentShades[labels[i]] = hex;
            const div = document.createElement('div');
            div.className = 'shade-box'; div.style.backgroundColor = hex; div.setAttribute('data-label', labels[i]);
            div.onclick = () => copyText(hex);
            shadesContainer.appendChild(div);
        });
    }

    function addToHistory(hex) {
        if(colorHistory.length > 0 && colorHistory[0] === hex) return;
        colorHistory.unshift(hex); if(colorHistory.length > 20) colorHistory.pop();
        renderHistory();
    }

    function renderHistory() {
        historyList.innerHTML = '';
        if(colorHistory.length === 0) { historyList.innerHTML = '<div style="color:#999; font-size:0.8rem; text-align:center;">æš«ç„¡ç´€éŒ„</div>'; return; }
        colorHistory.forEach(hex => {
            const div = document.createElement('div'); div.className = 'history-item';
            div.innerHTML = `<div class="history-swatch" style="background-color:${hex}"></div><span class="history-hex">${hex}</span>`;
            // v32 Fix: Auto copy on click
            div.onclick = () => {
                const r = parseInt(hex.slice(1, 3), 16); const g = parseInt(hex.slice(3, 5), 16); const b = parseInt(hex.slice(5, 7), 16);
                updateColorInfo(r, g, b, hex); calculateHarmonies(r, g, b);
                copyText(hex);
            };
            historyList.appendChild(div);
        });
    }

    function saveCurrentColor() {
        if(!currentMainColor) { alert('è«‹å…ˆé¸æ“‡ä¸€å€‹é¡è‰²ï¼'); return; }
        let saves = JSON.parse(localStorage.getItem('momo_saved_colors') || "[]");
        if(!saves.includes(currentMainColor)) {
            saves.unshift(currentMainColor); if(saves.length > 20) saves.pop();
            localStorage.setItem('momo_saved_colors', JSON.stringify(saves));
            loadSavedColors();
        } else { alert('é€™å€‹é¡è‰²å·²ç¶“å­˜éäº†ï¼'); }
    }

    function deleteSavedColor(hex) {
        let saves = JSON.parse(localStorage.getItem('momo_saved_colors') || "[]");
        saves = saves.filter(c => c !== hex);
        localStorage.setItem('momo_saved_colors', JSON.stringify(saves));
        loadSavedColors();
    }
    
    function clearSavedColors() {
        if(confirm('ç¢ºå®šè¦æ¸…ç©ºæ‰€æœ‰å„²å­˜çš„é¡è‰²å—ï¼Ÿ')) {
            localStorage.removeItem('momo_saved_colors');
            loadSavedColors();
        }
    }

    function loadSavedColors() {
        const saves = JSON.parse(localStorage.getItem('momo_saved_colors') || "[]");
        savedList.innerHTML = '';
        if(saves.length === 0) { savedList.innerHTML = '<div style="color:#999; font-size:0.8rem; text-align:center;">æš«ç„¡æ”¶è—</div>'; return; }
        saves.forEach(hex => {
            const div = document.createElement('div'); div.className = 'saved-item';
            div.innerHTML = `<div class="saved-info" onclick="restoreColor('${hex}')"><div class="saved-swatch" style="background-color:${hex}"></div><span style="font-family:monospace; font-size:0.9rem;">${hex}</span></div><div class="delete-btn" onclick="deleteSavedColor('${hex}')">Ã—</div>`;
            savedList.appendChild(div);
        });
    }

    function restoreColor(hex) {
        const r = parseInt(hex.slice(1, 3), 16); const g = parseInt(hex.slice(3, 5), 16); const b = parseInt(hex.slice(5, 7), 16);
        updateColorInfo(r, g, b, hex); calculateHarmonies(r, g, b);
        document.getElementById('targetColorPicker').value = hex; document.getElementById('targetHexInput').value = hex;
    }

    // --- Harmonies ---
    function calculateHarmonies(r, g, b) {
        const [h, s, l] = rgbToHsl(r, g, b);
        const mainHex = rgbToHex(r, g, b);
        const rules = { 'ana': [-30, 30], 'comp': [180], 'tri': [120, 240], 'split': [150, 210] };
        
        document.getElementById('mockupSection').style.display = 'block';
        document.getElementById('harmonyContainer').style.opacity = '1';
        document.getElementById('harmonyContainer').style.pointerEvents = 'auto';
        
        const isDarkBg = l < 0.5; const fillL = isDarkBg ? 0.92 : 0.15; const strokeL = isDarkBg ? 0.60 : 0.45; 
        document.querySelectorAll('.harmony-group').forEach(el => el.classList.remove('active'));

        for(let key in rules) {
            const container = document.getElementById(`harmony-${key}`);
            if(!container) continue;
            container.innerHTML = ''; container.appendChild(createColorBox(mainHex, true));
            let schemeColors = [];
            rules[key].forEach((degree, index) => {
                let newH = (h + degree) % 360; if(newH < 0) newH += 360;
                let activeL = (index === 0) ? fillL : strokeL; if(rules[key].length === 1) activeL = fillL;
                const [newR, newG, newB] = hslToRgb(newH, s, activeL);
                const hex = rgbToHex(newR, newG, newB);
                container.appendChild(createColorBox(hex)); schemeColors.push(hex);
            });
            const group = document.getElementById(`group-${key}`);
            if(group) {
                group.onclick = () => {
                    document.querySelectorAll('.harmony-group').forEach(el => el.classList.remove('active'));
                    group.classList.add('active');
                    updateMockup(mainHex, schemeColors);
                    updateGradient(mainHex, schemeColors[0]);
                }
            }
            if(key === 'ana') { 
                group.classList.add('active'); updateMockup(mainHex, schemeColors); updateGradient(mainHex, schemeColors[0]);
            }
        }
    }
    
    function createColorBox(hex, isMain = false) {
        const box = document.createElement('div'); box.className = 'h-box'; box.style.backgroundColor = hex;
        if(isMain) { box.style.border = "2px solid #333"; box.style.flex = "0 0 35px"; }
        box.onclick = (e) => { e.stopPropagation(); copyText(hex); }; return box;
    }
    
    function swapMockupColors() {
        const currentFill = mockupBox.style.getPropertyValue('--mockup-text');
        const currentStroke = mockupBox.style.getPropertyValue('--mockup-stroke');
        if (currentFill && currentStroke) {
            mockupBox.style.setProperty('--mockup-text', currentStroke);
            mockupBox.style.setProperty('--mockup-stroke', currentFill);
        } else {
            const bg = mockupBox.style.getPropertyValue('--mockup-bg');
            if(bg) { const txt = '#ffffff'; mockupBox.style.setProperty('--mockup-bg', txt); mockupBox.style.setProperty('--mockup-text', bg); }
        }
    }

    function updateMockup(bgHex, colors) { mockupBox.style.setProperty('--mockup-bg', bgHex); mockupBox.style.setProperty('--mockup-text', colors[0] || '#fff'); mockupBox.style.setProperty('--mockup-stroke', colors[1] || colors[0]); }
    function updateGradient(c1, c2) { c2=c2||c1; gradientPreview.style.background = `linear-gradient(135deg, ${c1}, ${c2})`; currentGradientCSS=`background: linear-gradient(135deg, ${c1}, ${c2})`; }
    function copyGradient() { if(currentGradientCSS) copyText(currentGradientCSS); }
    function exportTailwindConfig() {
        if(Object.keys(currentShades).length === 0) { alert('è«‹å…ˆé¸æ“‡ä¸€å€‹é¡è‰²ç”Ÿæˆè‰²éš'); return; }
        let c = `// tailwind.config.js\nmodule.exports = {\n  theme: {\n    extend: {\n      colors: {\n        'brand': {\n`;
        Object.keys(currentShades).forEach(k => c+=`          ${k}: '${currentShades[k]}',\n`);
        c+=`        }\n      }\n    }\n  }\n}`; copyText(c); alert('Copied!');
    }
    function downloadPaletteCard() {
        const boxes = document.querySelectorAll('#paletteContainer .color-card');
        if(boxes.length === 0) { alert('è«‹å…ˆä¸Šå‚³åœ–ç‰‡'); return; }
        const cardCanvas = document.createElement('canvas'); const ctx = cardCanvas.getContext('2d');
        const width = 800; const height = 600; cardCanvas.width = width; cardCanvas.height = height;
        ctx.fillStyle = '#ffffff'; ctx.fillRect(0, 0, width, height);
        ctx.fillStyle = '#333'; ctx.font = 'bold 30px sans-serif'; ctx.fillText('ChromaLab Palette', 40, 50);
        const imgRatio = mainCanvas.width / mainCanvas.height;
        let drawW = 400; let drawH = 400 / imgRatio; if(drawH > 450) { drawH = 450; drawW = 450 * imgRatio; }
        const imgX = 40; const imgY = 80;
        ctx.drawImage(mainCanvas, 0, 0, mainCanvas.width, mainCanvas.height, imgX, imgY, drawW, drawH);
        ctx.strokeStyle = '#eee'; ctx.lineWidth = 2; ctx.strokeRect(imgX, imgY, drawW, drawH);
        const startX = imgX + drawW + 40; let startY = 80; const boxHeight = 50; const boxWidth = 250;
        boxes.forEach((box, i) => {
            const hex = box.querySelector('.hex-text').innerText; const pct = box.querySelector('.pct-text').innerText; const color = box.style.backgroundColor;
            ctx.fillStyle = color; ctx.fillRect(startX, startY, 60, boxHeight);
            ctx.fillStyle = '#f8f9fa'; ctx.fillRect(startX + 60, startY, boxWidth - 60, boxHeight);
            ctx.fillStyle = '#333'; ctx.font = 'bold 18px monospace'; ctx.fillText(hex, startX + 75, startY + 32);
            ctx.fillStyle = '#666'; ctx.font = '14px sans-serif'; ctx.fillText(pct, startX + 180, startY + 32);
            startY += boxHeight + 15;
        });
        ctx.fillStyle = '#999'; ctx.font = '14px sans-serif'; ctx.fillText('Generated by ChromaLab Pro', width - 240, height - 20);
        const link = document.createElement('a'); link.download = 'chromalab-palette.jpg';
        link.href = cardCanvas.toDataURL('image/jpeg', 0.9); link.click();
    }

    // --- Color Math ---
    function rgbToCmyk(r, g, b) { let c = 1 - (r/255), m = 1 - (g/255), y = 1 - (b/255), k = Math.min(c, m, y); c = (c-k)/(1-k)||0; m = (m-k)/(1-k)||0; y = (y-k)/(1-k)||0; return { c:Math.round(c*100), m:Math.round(m*100), y:Math.round(y*100), k:Math.round(k*100) }; }
    function rgbToHsl(r, g, b) { r /= 255; g /= 255; b /= 255; const max = Math.max(r, g, b), min = Math.min(r, g, b); let h, s, l = (max + min) / 2; if (max === min) h = s = 0; else { const d = max - min; s = l > 0.5 ? d / (2 - max - min) : d / (max + min); switch (max) { case r: h = (g - b) / d + (g < b ? 6 : 0); break; case g: h = (b - r) / d + 2; break; case b: h = (r - g) / d + 4; break; } h *= 60; } return [h, s, l]; }
    function hslToRgb(h, s, l) { let r, g, b; if (s === 0) r = g = b = l; else { const hue2rgb = (p, q, t) => { if (t < 0) t += 1; if (t > 1) t -= 1; if (t < 1/6) return p + (q - p) * 6 * t; if (t < 1/2) return q; if (t < 2/3) return p + (q - p) * (2/3 - t) * 6; return p; }; const q = l < 0.5 ? l * (1 + s) : l + s - l * s; const p = 2 * l - q; r = hue2rgb(p, q, h/360 + 1/3); g = hue2rgb(p, q, h/360); b = hue2rgb(p, q, h/360 - 1/3); } return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)]; }
    function rgbToOklch(r, g, b) { const toLinear = (c) => { const v = c / 255; return v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4); }; const lr = toLinear(r), lg = toLinear(g), lb = toLinear(b); const l = 0.4122214708 * lr + 0.5363325363 * lg + 0.0514459929 * lb; const m = 0.2119034982 * lr + 0.6806995451 * lg + 0.1073969566 * lb; const s = 0.0883024619 * lr + 0.2817188376 * lg + 0.6299787005 * lb; const l_ = Math.cbrt(l), m_ = Math.cbrt(m), s_ = Math.cbrt(s); const L = 0.2104542553 * l_ + 0.7936177850 * m_ - 0.0040720468 * s_; const a = 1.9779984951 * l_ - 2.4285922050 * m_ + 0.4505937099 * s_; const b_ = 0.0259040371 * l_ + 0.7827717662 * m_ - 0.8086757660 * s_; const C = Math.sqrt(a * a + b_ * b_); let H = Math.atan2(b_, a) * (180 / Math.PI); if (H < 0) H += 360; return `${(L * 100).toFixed(1)}% ${C.toFixed(3)} ${H.toFixed(1)}`; }

    document.getElementById('resetBtn').addEventListener('click', () => location.reload());
</script>
</body>
</html>
